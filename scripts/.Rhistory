mutate(
Rank_Change = Rank_Forcing - Rank_Standard,
Standard_Cost = scales::dollar(round(Cost_Per_Ton_Standard, 0)),
Forcing_Cost = scales::dollar(round(Cost_Per_Forcing_Unit, 0))
) %>%
select(Scenario, Rank_Standard, Rank_Forcing, Rank_Change, Standard_Cost, Forcing_Cost)
ranking_comparison %>%
mutate(
Rank_Change = case_when(
Rank_Change == 0 ~ "No change",
Rank_Change > 0 ~ paste("Drops", abs(Rank_Change), "positions"),
Rank_Change < 0 ~ paste("Improves", abs(Rank_Change), "positions")
)
) %>%
kable(caption = "Dual Cost-Effectiveness Rankings: How Tipping Points Perspective Changes Priority",
col.names = c("Scenario", "Standard Rank", "Tipping Points Rank", "Ranking Change",
"$/ton CO2e", "$/Forcing Unit")) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE, font_size = 14) %>%
add_header_above(c(" " = 3, " " = 1, "Cost-Effectiveness" = 2))
# CORRECTED radiative forcing analysis
years <- 0:30
ch4_lifetime <- 9.5  # years
# CORRECTED calculate_forcing function
calculate_forcing <- function(scenario_name) {
# BASELINE: Full gas + electric emissions (highest)
if (scenario_name == "baseline") {
annual_co2_tons <- baseline_electric_emissions_tons +
(baseline_gas_emissions_tons - ch4_co2e_tons)  # CO2 component only
annual_ch4_tons <- ch4_co2e_tons / 84  # Convert back to CH4 mass
# SOLAR+BATTERY: Uses corrected net metering calculation
} else if (scenario_name == "solar_battery") {
# CORRECTED: Apply the net metering benefit
reduced_electric_emissions <- baseline_electric_emissions_tons - corrected_analysis$total_annual_benefit_tons
annual_co2_tons <- reduced_electric_emissions +
(baseline_gas_emissions_tons - ch4_co2e_tons)  # Gas CO2 unchanged
annual_ch4_tons <- ch4_co2e_tons / 84  # Gas appliances unchanged
# HEAT PUMPS: Eliminate most gas, add electric load (lowest)
} else if (scenario_name == "heat_pumps") {
stove_only_therms <- 15
stove_gas_co2_tons <- stove_only_therms * 13.5 / 2000
stove_ch4_tons <- stove_only_therms * 0.045 * 2.5 / 2000 / 84  # CH4 mass
electric_with_heat_pumps <- (baseline_electric_kwh + 7400) * 1.35 / 2000
annual_co2_tons <- electric_with_heat_pumps + stove_gas_co2_tons
annual_ch4_tons <- stove_ch4_tons
}
# Track atmospheric concentrations over time
results <- data.frame(year = years, co2_atmospheric = 0, ch4_atmospheric = 0)
for (i in 1:length(years)) {
# CO2 accumulates (very slow decay)
if (i == 1) {
results$co2_atmospheric[i] <- annual_co2_tons * 0.45  # 45% airborne fraction
} else {
results$co2_atmospheric[i] <- results$co2_atmospheric[i-1] * 0.99 + annual_co2_tons * 0.45
}
# CH4 decays exponentially
if (i == 1) {
results$ch4_atmospheric[i] <- annual_ch4_tons
} else {
decay_factor <- exp(-1/ch4_lifetime)
results$ch4_atmospheric[i] <- results$ch4_atmospheric[i-1] * decay_factor + annual_ch4_tons
}
}
# Convert to radiative forcing (relative units)
results$co2_forcing <- results$co2_atmospheric * 0.02
results$ch4_forcing_20yr <- results$ch4_atmospheric * 0.84  # 84x more potent
results$total_forcing_20yr <- results$co2_forcing + results$ch4_forcing_20yr
results$cumulative_forcing <- cumsum(results$total_forcing_20yr)
results$scenario <- scenario_name
return(results)
}
# Calculate for all scenarios with CORRECTED logic
rf_baseline <- calculate_forcing("baseline")
rf_solar_battery <- calculate_forcing("solar_battery")
rf_heat_pumps <- calculate_forcing("heat_pumps")
rf_all <- bind_rows(rf_baseline, rf_solar_battery, rf_heat_pumps)
# Create CORRECTED visualization
p_radiative_forcing <- ggplot(rf_all, aes(x = year, y = cumulative_forcing, color = scenario)) +
geom_line(size = 1.5) +
annotate("rect", xmin = 0, xmax = 20, ymin = -Inf, ymax = Inf, alpha = 0.1, fill = "red") +
annotate("text", x = 10, y = max(rf_all$cumulative_forcing) * 0.9,
label = "Critical 20-year period\n(tipping points window)", size = 4, color = "darkred") +
scale_color_manual(values = c("baseline" = "red", "solar_battery" = "blue", "heat_pumps" = "green"),
labels = c("Baseline", "Solar+Battery (CORRECTED)", "Heat Pumps")) +
scale_y_continuous(labels = scales::comma) +
labs(title = "CORRECTED: Cumulative Climate Forcing Over Time",
subtitle = "Net metering correction shows proper emission reductions below baseline",
x = "Years from Implementation",
y = "Cumulative Radiative Forcing (relative units)",
color = "Scenario",
caption = "CORRECTED: Solar+battery shows significant reduction. Methane: 84x warming, 9.5-year lifetime.") +
theme_minimal() +
theme(legend.position = "bottom",
plot.title = element_text(size = 16, face = "bold"))
print(p_radiative_forcing)
decision_matrix <- data.frame(
Consideration = c(
"Immediate methane elimination",
"Long-term CO2 reduction",
"Cost-effectiveness (standard)",
"Cost-effectiveness (tipping points)",
"Installation complexity",
"Home value impact",
"Energy independence"
),
Heat_Pumps = c(
"Excellent (complete gas elimination)",
"Good (but adds electric load)",
paste("#", ranking_comparison$Rank_Standard[grepl("Heat Pump", ranking_comparison$Scenario)]),
paste("#", ranking_comparison$Rank_Forcing[grepl("Heat Pump", ranking_comparison$Scenario)]),
"Moderate (HVAC contractor)",
"Moderate (+$5-10K)",
"Low (still grid dependent)"
),
Solar_Battery_CORRECTED = c(
"Good (temporal arbitrage)",
"Excellent (25-year production)",
paste("#", ranking_comparison$Rank_Standard[grepl("Solar", ranking_comparison$Scenario)]),
paste("#", ranking_comparison$Rank_Forcing[grepl("Solar", ranking_comparison$Scenario)]),
"High (electrical service upgrade)",
"Excellent (+$15-25K)",
"High (energy generation + storage)"
),
Both_Systems = c(
"Excellent (complete + temporal)",
"Excellent (maximum reduction)",
"Lower (highest cost)",
"Higher (maximum forcing reduction)",
"Highest (both installations)",
"Highest (+$20-35K)",
"Maximum (generation + no gas)"
)
)
decision_matrix %>%
kable(caption = "Decision Framework: Investment Option Comparison",
col.names = c("Consideration", "Heat Pumps Only", "Solar+Battery (CORRECTED)", "Combined Systems")) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = TRUE, font_size = 13) %>%
column_spec(1, bold = TRUE, width = "25%") %>%
row_spec(c(3,4), background = "#f0f8f0")
# Key corrected numbers for decision
final_summary <- data.frame(
Metric = c(
"Net grid exports benefit",
"Battery evening extension",
"Manufacturing offset period",
"Total corrected annual benefit",
"Cost-effectiveness ($/ton CO2e)",
"Climate urgency ranking"
),
Value = c(
paste(round(corrected_analysis$net_grid_benefit_tons, 1), "tons CO2e/year"),
paste(round(corrected_analysis$battery_annual_benefit_tons, 1), "tons CO2e/year"),
paste(round(corrected_analysis$manufacturing_offset_years, 1), "years"),
paste(round(corrected_analysis$total_annual_benefit_tons, 1), "tons CO2e/year"),
paste("$", round(scenarios$Cost_Per_Ton_Standard[scenarios$Scenario == "Solar+Battery (CORRECTED)"], 0), "/ton", sep=""),
"Significantly improved"
),
Explanation = c(
"Export during gas peakers, import during baseload",
"5 kWh daily discharge during evening gas dispatch",
"Time to offset solar panel & battery production emissions",
"Combined net metering + battery temporal arbitrage",
"Based on 10-year avoided emissions vs upfront cost",
"Tipping points perspective values immediate methane impact"
)
)
final_summary %>%
kable(caption = "CORRECTED Analysis Summary: Key Decision Metrics",
col.names = c("Decision Metric", "Corrected Value", "Technical Explanation")) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = TRUE, font_size = 14) %>%
column_spec(1, bold = TRUE, width = "25%") %>%
row_spec(4, bold = TRUE, background = "#e8f5e8")
# Clear environment and set up
rm(list=ls())
# Set working directory relative to .Rmd location FIRST
r_scriptwd <- getwd()
wd <- dirname(r_scriptwd)
knitr::opts_knit$set(root.dir = wd)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.width = 12, fig.height = 8, dpi = 150, fig.align = "center")
# Package management
packages <- c("tidyverse", "lubridate", "plotly", "kableExtra", "scales", "viridis", "patchwork")
new.packages <- packages[!(packages %in% installed.packages()[, "Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(packages, library, character.only = TRUE)
# Load house profile from House Component - DO NOT HARDCODE
# Working directory now set correctly above
if(!file.exists("output/house_profile.RData")) {
stop("house_profile.RData not found. Run House Component analysis first.")
}
load("output/house_profile.RData")
# Validate house profile loaded correctly
if(!exists("house_profile")) {
stop("house_profile object not found in loaded data.")
}
cat("=== LOADING VALIDATED HOUSE DATA ===\n")
cat("House profile version:", house_profile$version, "\n")
cat("Analysis date:", house_profile$analysis_date, "\n")
cat("Validation status:", house_profile$gas_appliance_breakdown$validation_status, "\n")
# INTEGRATED emissions factors - TROPOMI methane + detailed dispatch
emissions_factors <- list(
# Natural gas - UPDATED to TROPOMI satellite data (4.5% leakage)
gas_scenarios = list(
# EPA bottom-up estimates (conservative, facility-reported)
epa_conservative = list(
name = "EPA GHGI",
ch4_leakage_rate = 0.023,    # 2.3% (EPA Greenhouse Gas Inventory 2024)
source = "EPA bottom-up facility reports",
total_co2e_per_therm_20yr = 13.5 + (2.5 * 0.023 * 84)  # ~18.33 lbs/therm
),
# Alvarez et al. 2018 Science - 60% higher than EPA
alvarez_science = list(
name = "Alvarez Science 2018",
ch4_leakage_rate = 0.037,    # 60% higher than EPA (~3.7%)
source = "Facility-scale synthesis, top-down measurements",
total_co2e_per_therm_20yr = 13.5 + (2.5 * 0.037 * 84)  # ~21.27 lbs/therm
),
# TROPOMI satellite inversions - NOW BASELINE (updated from older script)
tropomi_satellite = list(
name = "TROPOMI Satellite",
ch4_leakage_rate = 0.045,    # 4.5% (high-resolution satellite inversions)
source = "Nesser et al. 2024 ACP, TROPOMI inversions",
total_co2e_per_therm_20yr = 13.5 + (2.5 * 0.045 * 84)  # ~22.95 lbs/therm
),
# EDF aircraft campaigns - highest measured rates
edf_aircraft = list(
name = "EDF MethaneAIR",
ch4_leakage_rate = 0.092,    # ~4x EPA (9.2%) from aerial surveys
source = "EDF MethaneAIR aircraft campaigns, surveyed basins",
total_co2e_per_therm_20yr = 13.5 + (2.5 * 0.092 * 84)  # ~32.82 lbs/therm
)
),
# Use TROPOMI satellite data as baseline (UPDATED from 2.5% to 4.5%)
gas_baseline = list(
co2_per_therm = 11.7 + 1.8,  # Combustion + upstream
ch4_leakage_rate = 0.045,    # 4.5% TROPOMI satellite measurements (UPDATED)
ch4_lbs_per_therm = 2.5,
ch4_gwp_20yr = 84,           # IPCC AR6 - tipping points metric
ch4_gwp_100yr = 28,          # IPCC AR6 - traditional metric
ch4_lifetime_yr = 9.5,       # Atmospheric decay time
total_co2e_per_therm_20yr = 13.5 + (2.5 * 0.045 * 84)  # ~22.95 lbs/therm
)
)
# Calculate baseline emissions with sensitivity analysis
baseline_gas_therms <- house_profile$baseline_consumption$annual_therms_gas
baseline_electric_kwh <- house_profile$baseline_consumption$annual_kwh_electric
# Calculate emissions for each methane leakage scenario
methane_sensitivity <- map_dfr(emissions_factors$gas_scenarios, ~{
gas_emissions_tons <- baseline_gas_therms * .x$total_co2e_per_therm_20yr / 2000
electric_emissions_tons <- baseline_electric_kwh * 1.35 / 2000  # Will be replaced by dispatch model
total_emissions <- gas_emissions_tons + electric_emissions_tons
# Methane component
ch4_leaked_lbs <- baseline_gas_therms * .x$ch4_leakage_rate * 2.5
ch4_co2e_tons <- ch4_leaked_lbs * 84 / 2000
methane_share_percent <- (ch4_co2e_tons / gas_emissions_tons) * 100
data.frame(
scenario = .x$name,
leakage_rate_pct = .x$ch4_leakage_rate * 100,
source = .x$source,
gas_emissions_tons = round(gas_emissions_tons, 1),
electric_emissions_tons = round(electric_emissions_tons, 1),
total_emissions_tons = round(total_emissions, 1),
methane_share_pct = round(methane_share_percent, 0),
stringsAsFactors = FALSE
)
})
# Use TROPOMI satellite data as baseline for main analysis
baseline_gas_emissions_tons <- methane_sensitivity$gas_emissions_tons[methane_sensitivity$scenario == "TROPOMI Satellite"]
baseline_electric_emissions_tons <- methane_sensitivity$electric_emissions_tons[1]  # Will be updated by dispatch
total_baseline_emissions <- baseline_gas_emissions_tons + baseline_electric_emissions_tons
# Methane component using TROPOMI rates
ch4_leaked_lbs <- baseline_gas_therms * emissions_factors$gas_baseline$ch4_leakage_rate * emissions_factors$gas_baseline$ch4_lbs_per_therm
ch4_co2e_tons <- ch4_leaked_lbs * emissions_factors$gas_baseline$ch4_gwp_20yr / 2000
methane_share_percent <- (ch4_co2e_tons / baseline_gas_emissions_tons) * 100
methane_sensitivity %>%
kable(caption = "UPDATED: Methane Leakage Sensitivity Analysis (Now Using TROPOMI 4.5%)",
col.names = c("Study/Method", "Leakage Rate (%)", "Source",
"Gas Emissions (tons CO2e/yr)", "Electric Emissions (tons CO2e/yr)",
"Total Emissions (tons CO2e/yr)", "Methane Share (%)")) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE, font_size = 14) %>%
row_spec(3, bold = TRUE, background = "#e8f5e8") %>%  # Highlight TROPOMI baseline (NOW UPDATED)
row_spec(4, background = "#ffe6e6") %>%  # Highlight highest case
add_header_above(c(" " = 3, "Annual Emissions" = 3, " " = 1))
# Georgia Power merit order dispatch emissions - INTEGRATED from older script
calculate_hourly_emissions <- function(datetime, grid_year = 2025) {
hour <- hour(datetime)
month <- month(datetime)
wday <- wday(datetime)
# Base emissions by generation type (lbs CO2/kWh)
emissions_by_type <- list(
nuclear = 0,           # Zero emissions
coal = 2.23,          # Lignite/sub-bituminous
gas_cc = 0.91,        # Combined cycle
gas_ct = 1.22,        # Combustion turbine (peaker) - DIRTIEST
solar = 0,            # Zero operational
wind = 0              # Zero operational
)
# Hourly dispatch logic based on merit order and load
if(hour >= 0 & hour < 6) {
# Night: Baseload only (nuclear + coal) - CLEANEST HOURS
nuclear_share <- 0.35
coal_share <- 0.65
gas_cc_share <- 0
gas_ct_share <- 0  # No peakers
solar_share <- 0
} else if(hour >= 6 & hour < 10) {
# Morning ramp: Add combined cycle
nuclear_share <- 0.25
coal_share <- 0.45
gas_cc_share <- 0.30
gas_ct_share <- 0  # Still no peakers
solar_share <- 0
} else if(hour >= 10 & hour < 14) {
# Midday: Solar contribution (summer stronger)
nuclear_share <- 0.20
coal_share <- 0.35
if(month %in% 5:9) {
solar_share <- 0.15  # Utility solar peaks
gas_cc_share <- 0.30
} else {
solar_share <- 0.05
gas_cc_share <- 0.40
}
gas_ct_share <- 0  # Still no peakers
} else if(hour >= 14 & hour < 19) {
# Peak demand: ALL resources including peakers - DIRTIEST HOURS
nuclear_share <- 0.15
coal_share <- 0.30
gas_cc_share <- 0.30
gas_ct_share <- 0.20  # PEAKERS RUNNING - key for solar export value
solar_share <- ifelse(month %in% 5:9 & hour < 18, 0.05, 0)
} else {
# Evening ramp down: Some gas still running
nuclear_share <- 0.25
coal_share <- 0.40
gas_cc_share <- 0.35
gas_ct_share <- 0.05  # Some peakers still on
solar_share <- 0
}
# Calculate weighted emissions factor
emissions_factor <-
nuclear_share * emissions_by_type$nuclear +
coal_share * emissions_by_type$coal +
gas_cc_share * emissions_by_type$gas_cc +
gas_ct_share * emissions_by_type$gas_ct +
solar_share * emissions_by_type$solar
# Apply grid evolution scaling (gets cleaner over time)
grid_evolution_factor <- case_when(
grid_year <= 2025 ~ 1.0,
grid_year <= 2030 ~ 0.85,
grid_year <= 2035 ~ 0.65,
TRUE ~ 0.45
)
# Add 10% transmission losses
return(emissions_factor * grid_evolution_factor * 1.1)
}
# Create comprehensive daily emissions profiles
create_daily_emissions_profile <- function(season = "summer", year = 2025) {
hours <- 0:23
month <- ifelse(season == "summer", 7, 1)
emissions <- sapply(hours, function(h) {
datetime <- as.POSIXct(paste0(year, "-", sprintf("%02d", month), "-15 ",
sprintf("%02d", h), ":00:00"),
tz = "America/New_York")
calculate_hourly_emissions(datetime, year)
})
data.frame(
hour = hours,
emissions_factor = emissions,
season = season,
year = year,
period = case_when(
hours >= 0 & hours < 6 ~ "Night Baseload (Cleanest)",
hours >= 6 & hours < 14 ~ "Morning/Midday Ramp",
hours >= 14 & hours < 19 ~ "Peak + Peakers (Dirtiest)",
TRUE ~ "Evening Ramp Down"
)
)
}
# Generate profiles for analysis
summer_profile <- create_daily_emissions_profile("summer", 2025)
winter_profile <- create_daily_emissions_profile("winter", 2025)
# DISPATCH VISUALIZATION - Individual plot optimized for iPad
p_dispatch <- ggplot() +
geom_line(data = summer_profile,
aes(x = hour, y = emissions_factor, color = "Summer"),
size = 1.5) +
geom_line(data = winter_profile,
aes(x = hour, y = emissions_factor, color = "Winter"),
size = 1.5) +
# Highlight key periods
annotate("rect", xmin = 14, xmax = 19, ymin = 0, ymax = Inf,
alpha = 0.2, fill = "red") +
annotate("rect", xmin = 0, xmax = 6, ymin = 0, ymax = Inf,
alpha = 0.1, fill = "blue") +
# Labels for key insights
annotate("text", x = 16.5, y = 0.4,
label = "PEAK HOURS\nGas Peakers\n(Dirtiest)",
size = 4, fontface = "bold", color = "darkred") +
annotate("text", x = 3, y = 0.4,
label = "NIGHT BASELOAD\nNuclear/Coal\n(Cleanest)",
size = 4, fontface = "bold", color = "darkblue") +
geom_hline(yintercept = mean(summer_profile$emissions_factor),
linetype = "dashed", alpha = 0.7, color = "gray") +
annotate("text", x = 20, y = mean(summer_profile$emissions_factor) + 0.05,
label = "Daily Average", size = 3) +
scale_x_continuous(breaks = seq(0, 23, 3)) +
scale_color_manual(values = c("Summer" = "red", "Winter" = "blue")) +
labs(title = "Georgia Power Hourly Emissions: Merit Order Dispatch Analysis",
subtitle = "Gas peakers (2-7 PM) create 35% higher emissions than night baseload",
x = "Hour of Day",
y = "Emissions Factor (lbs CO2/kWh)",
color = "Season",
caption = "Red = Peak hours when solar exports, Blue = Night hours when grid imports occur") +
theme_minimal() +
theme(legend.position = "bottom",
plot.title = element_text(size = 16, face = "bold"),
plot.subtitle = element_text(size = 14))
print(p_dispatch)
# Calculate key dispatch metrics for later use
peak_emissions_factor <- mean(filter(summer_profile, hour >= 14, hour < 19)$emissions_factor)
baseload_emissions_factor <- mean(filter(summer_profile, hour >= 0, hour < 6)$emissions_factor)
evening_emissions_factor <- mean(filter(summer_profile, hour >= 19, hour < 23)$emissions_factor)
cat("KEY DISPATCH METRICS:\n")
cat("Peak hours (2-7 PM):", round(peak_emissions_factor, 3), "lbs CO2e/kWh\n")
cat("Baseload (midnight-6 AM):", round(baseload_emissions_factor, 3), "lbs CO2e/kWh\n")
cat("Evening (7-11 PM):", round(evening_emissions_factor, 3), "lbs CO2e/kWh\n")
cat("Temporal arbitrage opportunity:", round((peak_emissions_factor/baseload_emissions_factor - 1) * 100, 0), "% higher emissions during peaks\n")
# INTEGRATED analysis combining both net metering temporal arbitrage AND battery load shifting
analyze_integrated_solar_battery <- function() {
# System specifications from house_profile
solar_annual_kwh <- house_profile$installer_system_full$annual_production_estimate
battery_kwh <- house_profile$installer_system_full$battery_capacity_kwh
annual_consumption_kwh <- house_profile$baseline_consumption$annual_kwh_electric
# Solar generation pattern (typical day)
solar_generation <- c(rep(0, 6), 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 3.5, 3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.2, rep(0, 3))
# House consumption pattern (from data)
house_consumption <- c(0.5, 0.4, 0.4, 0.4, 0.4, 0.6, 0.8, 1.0, 0.9, 0.8, 0.7, 0.7,
0.8, 0.9, 1.2, 1.4, 1.5, 1.6, 1.4, 1.2, 1.0, 0.8, 0.6, 0.5)
# Hourly emissions factors (from dispatch model)
hourly_emissions <- sapply(0:23, function(h) {
datetime <- as.POSIXct(paste0("2025-07-15 ", sprintf("%02d", h), ":00:00"), tz = "America/New_York")
calculate_hourly_emissions(datetime, 2025)
})
# Create comprehensive hourly analysis
hourly_analysis <- data.frame(
hour = 0:23,
solar_generation = solar_generation,
house_consumption = house_consumption,
emissions_factor = hourly_emissions,
# Net metering analysis (without battery first)
net_generation = solar_generation - house_consumption,  # Positive = export, Negative = import
# Battery operation strategy
battery_action = case_when(
0:23 >= 12 & 0:23 < 14 ~ "charge",     # Charge from excess solar
0:23 >= 18 & 0:23 < 22 ~ "discharge",  # Discharge during evening peak
TRUE ~ "idle"
),
# Battery energy flow (5 kWh daily cycle at 96% efficiency)
battery_kwh = case_when(
battery_action == "charge" ~ battery_kwh/2 * 1.04,      # Charge over 2 hours with losses
battery_action == "discharge" ~ -battery_kwh/4 * 0.96,  # Discharge over 4 hours with efficiency
TRUE ~ 0
)
) %>%
mutate(
# Scenarios for comparison
# Scenario 1: No solar, no battery (baseline grid consumption)
baseline_grid_kwh = house_consumption,
baseline_emissions = baseline_grid_kwh * emissions_factor,
# Scenario 2: Solar only (net metering)
solar_only_net_grid = net_generation,  # Positive = export, negative = import
solar_only_emissions = ifelse(solar_only_net_grid > 0,
-solar_only_net_grid * emissions_factor,  # Export credits (negative emissions)
-solar_only_net_grid * emissions_factor), # Import debits (positive emissions)
# Scenario 3: Solar + Battery (integrated system)
solar_battery_net_grid = net_generation - battery_kwh,  # Battery modifies net grid flow
solar_battery_emissions = ifelse(solar_battery_net_grid > 0,
-solar_battery_net_grid * emissions_factor,  # Export credits
-solar_battery_net_grid * emissions_factor), # Import debits
# Identify key periods for analysis
period = case_when(
hour >= 12 & hour < 14 ~ "Solar Excess (Battery Charge)",
hour >= 14 & hour < 18 ~ "Solar Direct Export",
hour >= 18 & hour < 22 ~ "Battery Discharge (Peak Avoidance)",
hour >= 0 & hour < 6 ~ "Night Import (Baseload)",
TRUE ~ "Transition Hours"
)
)
# Calculate daily totals
daily_totals <- list(
baseline_emissions = sum(hourly_analysis$baseline_emissions),
solar_only_emissions = sum(hourly_analysis$solar_only_emissions),
solar_battery_emissions = sum(hourly_analysis$solar_battery_emissions),
# Benefits
solar_only_benefit = sum(hourly_analysis$baseline_emissions) - sum(hourly_analysis$solar_only_emissions),
battery_additional_benefit = sum(hourly_analysis$solar_only_emissions) - sum(hourly_analysis$solar_battery_emissions),
total_system_benefit = sum(hourly_analysis$baseline_emissions) - sum(hourly_analysis$solar_battery_emissions),
# Annual extrapolation
annual_solar_only_tons = (sum(hourly_analysis$baseline_emissions) - sum(hourly_analysis$solar_only_emissions)) * 365 / 2000,
annual_battery_additional_tons = (sum(hourly_analysis$solar_only_emissions) - sum(hourly_analysis$solar_battery_emissions)) * 365 / 2000,
annual_total_benefit_tons = (sum(hourly_analysis$baseline_emissions) - sum(hourly_analysis$solar_battery_emissions)) * 365 / 2000
)
return(list(
hourly_data = hourly_analysis,
daily_totals = daily_totals
))
}
# Run the integrated analysis
integrated_results <- analyze_integrated_solar_battery()
