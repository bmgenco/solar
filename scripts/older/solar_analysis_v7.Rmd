---
  title: "House Component Analysis - Solar & Energy Decision Framework"
subtitle: "2265 Ridgedale Road, Decatur GA - Data Processing & System Sizing"
author: "Three-Component Decision Framework"
date: "`r Sys.Date()`"
output: 
  html_document:
  toc: true
toc_float: true
theme: flatly
code_folding: hide
---
  
  <!--
  SOLAR & ENERGY EFFICIENCY DECISION ANALYSIS - THREE COMPONENT FRAMEWORK
================================================================================
  Property: 2265 Ridgedale Road, Decatur GA (DeKalb County)
Timeline: Potential move in 1-10 years (continuous variable)
Priorities: Emissions reduction + financial ROI optimization

COMPONENT ARCHITECTURE:
  1. HOUSE COMPONENT (THIS FILE): CSV data processing, energy/temperature correlations, 
solar system sizing, battery/backup configuration decisions
2. FINANCIAL COMPONENT: Economic modeling, ROI calculations, home values
3. EMISSIONS COMPONENT: CO2 avoidance calculations, cost per ton, grid mix evolution

KEY DECISIONS SUPPORTED BY HOUSE COMPONENT:
  - Solar system size (3.8kW baseline from 6,540 kWh annual consumption)
- Battery storage: Yes/No and capacity sizing
- Sunlight Backup options and emergency power requirements
- Heat pump sizing for space heating and water heating conversion
- Panel upgrade requirements (200A needed for solar + renovations)
- Efficiency upgrade sequencing and impact quantification

CRITICAL TIMING: 30% federal tax credit expires 12/31/2025
INSTALLATION: Left to contractors - this analysis provides data for decision-making
OUTPUT: house_profile.RData for use by financial and emissions components
================================================================================
  -->
  
  ```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

# Package management function
f.ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

# Load required libraries
packages <- c("tidyverse", "lubridate", "plotly", "DT", "kableExtra", "readxl")
f.ipak(packages)
```
# edits
- edit data import structure and file paths reltive to markdown file
- see " 1a. Emporia Circuit-Level Data" keep all circuit data In general edit sciprt to keep all variables from input data functiosn then can e b writenfor specific varaibles
- see "1f. Natural Gas Usage Data (BMG Energy Company)" summer gas includes stove not just hot water heater
- see "1g. Data Anomaly Detection and System Events"  and comment out or if else starmnet as is makes up data to filter
- add function variables list to be set by use at begging of code
- see "1b. Ecobee Thermostat Data" -  add 3 room temepras to read ecobee,  can be use for future efccinty analysis.   In general "..."


# 1. Data Import Pipeline - Multiple Energy Sources

## 1a. Emporia Circuit-Level Data

```{r emporia_data_import}
# Function to load Emporia circuit-level energy monitoring data
load_emporia_data <- function(file_path, resolution = "daily") {
  
  # Column name mapping to clean up long Emporia names
  emporia_data <- read.csv(file_path, stringsAsFactors = FALSE)
  
  # Parse datetime
  emporia_data$datetime <- as.POSIXct(emporia_data[,1], 
                                      format = "%Y-%m-%d %H:%M:%S", 
                                      tz = "America/New_York")
  
  # Calculate total house consumption (Mains A + Mains B)
  mains_a_col <- grep("Mains_A", names(emporia_data), value = TRUE)[1]
  mains_b_col <- grep("Mains_B", names(emporia_data), value = TRUE)[1]
  
  emporia_data$total_house_kwh <- emporia_data[[mains_a_col]] + emporia_data[[mains_b_col]]
  
  # Clean up circuit names for easier analysis
  names(emporia_data) <- gsub("Ridgedale.electrical.meter.", "", names(emporia_data))
  names(emporia_data) <- gsub("\\.\\.kWhs\\.", "_kwh", names(emporia_data))
  names(emporia_data) <- gsub("\\.\\.kWatts\\.", "_kw", names(emporia_data))
  
  # Extract key circuits for analysis
  emporia_data <- emporia_data %>%
    rename_with(~ str_replace_all(.x, "\\.", "_")) %>%
    filter(!is.na(datetime), total_house_kwh > 0) %>%
    arrange(datetime)
  
  cat("=== EMPORIA DATA SUMMARY ===\n")
  cat("Date range:", min(emporia_data$datetime), "to", max(emporia_data$datetime), "\n")
  cat("Total records:", nrow(emporia_data), "\n")
  cat("Resolution:", resolution, "\n")
  cat("Total consumption:", round(sum(emporia_data$total_house_kwh, na.rm = TRUE), 1), "kWh\n")
  
  return(emporia_data)
}

# Load Emporia data - USER UPDATE PATH
# emporia_data <- load_emporia_data("path/to/emporia/file.csv", "daily")
```

## 1b. Ecobee Thermostat Data

```{r ecobee_data_import}
# Function to load and combine multiple Ecobee monthly CSV files
load_ecobee_data <- function(folder_path = "ecobee_data/") {
  
  # Get all CSV files in folder matching ecobee pattern
  csv_files <- list.files(folder_path, pattern = "report.*\\.csv$", full.names = TRUE)
  
  if(length(csv_files) == 0) {
    cat("No ecobee CSV files found in", folder_path, "\n")
    return(NULL)
  }
  
  cat("Found", length(csv_files), "ecobee files to process\n")
  
  # Read and combine all files
  ecobee_combined <- map_dfr(csv_files, function(file) {
    
    cat("Processing:", basename(file), "\n")
    
    # Read raw file to handle header metadata
    raw_lines <- readLines(file)
    
    # Find where actual CSV data starts (skip header metadata)
    csv_start <- which(str_detect(raw_lines, "^Date,Time,"))[1]
    
    if(is.na(csv_start)) {
      warning("Could not find CSV header in file: ", file)
      return(NULL)
    }
    
    # Extract metadata from header lines
    thermostat_id <- str_extract(raw_lines[1], "\\d+")
    start_date <- str_extract(raw_lines[3], "\\d{4}-\\d{2}-\\d{2}")
    end_date <- str_extract(raw_lines[4], "\\d{4}-\\d{2}-\\d{2}")
    
    # Write CSV data to temporary file (skip metadata lines)
    temp_file <- tempfile()
    writeLines(raw_lines[csv_start:length(raw_lines)], temp_file)
    
    # Read actual CSV data
    data <- read.csv(temp_file, stringsAsFactors = FALSE)
    unlink(temp_file)
    
    # Add metadata columns
    data$thermostat_id <- thermostat_id
    data$file_start_date <- start_date
    data$file_end_date <- end_date
    data$source_file <- basename(file)
    
    return(data)
  })
  
  if(is.null(ecobee_combined) || nrow(ecobee_combined) == 0) {
    warning("No data successfully loaded from ecobee files")
    return(NULL)
  }
  
  # Create proper datetime column
  ecobee_combined$datetime <- as.POSIXct(
    paste(ecobee_combined$Date, ecobee_combined$Time), 
    format = "%Y-%m-%d %H:%M:%S",
    tz = "America/New_York"
  )
  
  # Clean and standardize column names
  ecobee_combined <- ecobee_combined %>%
    rename_with(~ str_replace_all(.x, "\\.", "_")) %>%
    rename_with(~ str_replace_all(.x, "[()%]", "")) %>%
    rename_with(~ tolower(.x))
  
  # Create standardized column names for key metrics
  if("cool_set_temp_f" %in% names(ecobee_combined)) {
    ecobee_combined <- ecobee_combined %>%
      rename(
        cool_setpoint = cool_set_temp_f,
        heat_setpoint = heat_set_temp_f,
        current_temp = current_temp_f,
        current_humidity = current_humidity_rh,
        outdoor_temp = outdoor_temp_f,
        cool_runtime_sec = cool_stage_1_sec,
        heat_runtime_sec = heat_stage_1_sec,
        fan_runtime_sec = fan_sec
      )
  }
  
  # Sort by datetime and calculate derived metrics
  ecobee_combined <- ecobee_combined %>%
    arrange(datetime) %>%
    filter(!is.na(datetime)) %>%
    mutate(
      # Convert runtime seconds to minutes
      cool_runtime_min = cool_runtime_sec / 60,
      heat_runtime_min = heat_runtime_sec / 60,
      fan_runtime_min = fan_runtime_sec / 60,
      
      # Calculate total HVAC runtime
      total_hvac_runtime_min = cool_runtime_min + heat_runtime_min,
      
      # Date components for aggregation
      date = as.Date(datetime),
      hour = hour(datetime),
      month = month(datetime),
      year = year(datetime)
    )
  
  # Data quality summary
  cat("\n=== ECOBEE DATA SUMMARY ===\n")
  cat("Date range:", min(ecobee_combined$datetime), "to", max(ecobee_combined$datetime), "\n")
  cat("Total records:", nrow(ecobee_combined), "\n")
  cat("Data frequency: 5-minute intervals\n")
  cat("Total cooling runtime:", round(sum(ecobee_combined$cool_runtime_min, na.rm = TRUE) / 60, 1), "hours\n")
  cat("Total heating runtime:", round(sum(ecobee_combined$heat_runtime_min, na.rm = TRUE) / 60, 1), "hours\n")
  
  return(ecobee_combined)
}

# Load Ecobee data - USER UPDATE PATH
# ecobee_data <- load_ecobee_data("path/to/ecobee/files/")
```

## 1c. Georgia Power Usage and Cost Data

```{r ga_power_data_import}
# Function to load and combine Georgia Power Excel files (energy + cost)
load_ga_power_data <- function(energy_file_path, cost_file_path, data_type = "hourly") {
  
  # Function to read and clean individual GA Power file
  read_ga_power_file <- function(file_path, value_col_name) {
    # Read Excel file, skipping header rows
    raw_data <- read_excel(file_path, 
                           sheet = 1,
                           skip = 2,  # Skip disclaimer and account number rows
                           col_names = TRUE)
    
    # Clean column names
    names(raw_data) <- c("hour", "value", "temp")
    
    # Parse and clean data
    clean_data <- raw_data %>%
      mutate(
        # Convert hour to proper datetime
        datetime = if_else(
          is.character(hour),
          as.POSIXct(hour, format = "%Y-%m-%d %H:%M", tz = "America/New_York"),
          as.POSIXct(as.numeric(hour) * 86400, 
                     origin = "1899-12-30", tz = "America/New_York")
        ),
        
        # Clean value data (remove any non-numeric characters)
        !!value_col_name := as.numeric(str_replace_all(as.character(value), "[^0-9.-]", "")),
        
        # Clean temperature data (keep only one temp column)
        outdoor_temp = as.numeric(temp)
      ) %>%
      
      # Select only needed columns
      select(datetime, !!value_col_name, outdoor_temp) %>%
      
      # Remove rows with missing datetime
      filter(!is.na(datetime)) %>%
      arrange(datetime)
    
    return(clean_data)
  }
  
  cat("Loading Georgia Power data files...\n")
  
  # Load energy data (kWh)
  cat("Processing energy file:", basename(energy_file_path), "\n")
  energy_data <- read_ga_power_file(energy_file_path, "kwh_hourly")
  
  # Load cost data ($)
  cat("Processing cost file:", basename(cost_file_path), "\n")
  cost_data <- read_ga_power_file(cost_file_path, "cost_hourly")
  
  # Join the datasets by datetime using inner_join to ensure matching records
  ga_power_data <- energy_data %>%
    inner_join(cost_data %>% select(datetime, cost_hourly), 
               by = "datetime", 
               suffix = c("_energy", "_cost")) %>%
    
    # Add derived columns
    mutate(
      # Extract date components for aggregation
      date = as.Date(datetime),
      hour_of_day = hour(datetime),
      month = month(datetime),
      year = year(datetime),
      week_day = wday(datetime, label = TRUE),
      
      # Calculate effective rate ($/kWh) - handle division by zero
      rate_per_kwh = if_else(kwh_hourly > 0, cost_hourly / kwh_hourly, NA_real_),
      
      # Calculate time-of-use periods (adjust based on GA Power rate schedule)
      time_period = case_when(
        hour_of_day >= 14 & hour_of_day < 19 & 
          week_day %in% c("Mon", "Tue", "Wed", "Thu", "Fri") ~ "peak",        # 2-7 PM weekdays
        hour_of_day >= 6 & hour_of_day < 14 & 
          week_day %in% c("Mon", "Tue", "Wed", "Thu", "Fri") ~ "shoulder",    # 6 AM - 2 PM weekdays  
        TRUE ~ "off_peak"                                                     # Nights and weekends
      ),
      
      # Season for rate analysis
      season = case_when(
        month %in% c(6, 7, 8, 9) ~ "summer",
        month %in% c(12, 1, 2) ~ "winter", 
        TRUE ~ "spring_fall"
      )
    ) %>%
    arrange(datetime)
  
  # Data validation and quality checks
  cat("\n=== GEORGIA POWER COMBINED DATA SUMMARY ===\n")
  cat("Date range:", min(ga_power_data$datetime), "to", max(ga_power_data$datetime), "\n")
  cat("Total records:", nrow(ga_power_data), "\n")
  cat("Total kWh in period:", round(sum(ga_power_data$kwh_hourly, na.rm = TRUE), 1), "\n")
  cat("Total cost in period: $", round(sum(ga_power_data$cost_hourly, na.rm = TRUE), 2), "\n")
  
  # Rate analysis
  rate_stats <- ga_power_data %>%
    filter(!is.na(rate_per_kwh), is.finite(rate_per_kwh)) %>%
    summarise(
      avg_rate = mean(rate_per_kwh),
      median_rate = median(rate_per_kwh)
    )
  cat("Average rate: $", round(rate_stats$avg_rate, 4), "/kWh\n")
  
  return(ga_power_data)
}

# Load GA Power data - USER UPDATE PATHS
# ga_power_data <- load_ga_power_data("ENERGY_GPC_Usage_file.xlsx", "COST_GPC_Usage_file.xlsx")
```

## 1d. Data Quality Validation - Emporia vs Georgia Power

```{r emporia_ga_power_comparison}
# Function to compare Emporia vs Georgia Power energy data
compare_emporia_ga_power <- function(emporia_data, ga_power_data, 
                                     comparison_period = "daily") {
  
  cat("=== EMPORIA vs GEORGIA POWER COMPARISON ===\n")
  
  # Prepare Emporia data for comparison
  if(comparison_period == "daily") {
    emporia_agg <- emporia_data %>%
      mutate(date = as.Date(datetime)) %>%
      group_by(date) %>%
      summarise(
        emporia_total_kwh = sum(total_house_kwh, na.rm = TRUE),
        emporia_records = n(),
        .groups = 'drop'
      ) %>%
      filter(emporia_total_kwh > 0)  # Remove days with no data
    
    # Prepare GA Power data  
    ga_power_agg <- ga_power_data %>%
      group_by(date) %>%
      summarise(
        ga_power_total_kwh = sum(kwh_hourly, na.rm = TRUE),
        ga_power_records = n(),
        daily_cost = sum(cost_hourly, na.rm = TRUE),
        avg_temp = mean(outdoor_temp, na.rm = TRUE),
        .groups = 'drop'
      ) %>%
      filter(ga_power_total_kwh > 0)  # Remove days with no data
  }
  
  # Join the datasets
  comparison_data <- emporia_agg %>%
    inner_join(ga_power_agg, by = "date") %>%
    mutate(
      # Calculate differences
      kwh_difference = emporia_total_kwh - ga_power_total_kwh,
      kwh_difference_pct = (kwh_difference / ga_power_total_kwh) * 100,
      
      # Absolute difference for magnitude analysis
      abs_difference = abs(kwh_difference),
      abs_difference_pct = abs(kwh_difference_pct)
    ) %>%
    filter(
      # Remove periods with very low usage (measurement noise)
      ga_power_total_kwh > 0.1,
      emporia_total_kwh > 0.1
    )
  
  # Calculate summary metrics
  summary_stats <- comparison_data %>%
    summarise(
      emporia_total = sum(emporia_total_kwh),
      ga_power_total = sum(ga_power_total_kwh),
      total_difference = sum(kwh_difference),
      total_difference_pct = (total_difference / ga_power_total) * 100,
      correlation = cor(emporia_total_kwh, ga_power_total_kwh),
      mean_abs_difference_pct = mean(abs_difference_pct),
      large_discrepancies = sum(abs_difference_pct > 10)
    )
  
  # Print summary
  cat("Overlapping periods:", nrow(comparison_data), "\n")
  cat("Emporia total:", round(summary_stats$emporia_total, 1), "kWh\n")
  cat("GA Power total:", round(summary_stats$ga_power_total, 1), "kWh\n") 
  cat("Percentage difference:", round(summary_stats$total_difference_pct, 2), "%\n")
  cat("Correlation coefficient:", round(summary_stats$correlation, 3), "\n")
  cat("Mean absolute % difference:", round(summary_stats$mean_abs_difference_pct, 1), "%\n")
  cat("Periods with >10% discrepancy:", summary_stats$large_discrepancies, "\n")
  
  # Create scatter plot
  scatter_plot <- ggplot(comparison_data, 
                         aes(x = ga_power_total_kwh, y = emporia_total_kwh)) +
    geom_point(alpha = 0.6, color = "blue") +
    geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +
    geom_smooth(method = "lm", se = TRUE, color = "green") +
    labs(
      title = "Emporia vs GA Power - Daily Comparison",
      x = "GA Power kWh",
      y = "Emporia kWh",
      caption = paste("Correlation:", round(summary_stats$correlation, 3),
                      "| Total difference:", round(summary_stats$total_difference_pct, 1), "%")
    ) +
    theme_minimal()
  
  # Return results
  results <- list(
    comparison_data = comparison_data,
    summary_stats = summary_stats,
    scatter_plot = scatter_plot
  )
  
  return(results)
}

# Run data validation - USER EXECUTE AFTER DATA LOADING
# comparison_results <- compare_emporia_ga_power(emporia_data, ga_power_data, "daily")
# print(comparison_results$scatter_plot)
```

## 1e. Georgia Power Monthly Bills (CSV)

```{r ga_power_bills_import}
# Function to load and analyze Georgia Power monthly bill data
load_ga_power_bills <- function(file_path) {
  
  # Load monthly bill data (CSV format)
  bill_data <- read.csv(file_path, stringsAsFactors = FALSE)
  
  # Parse billing periods to extract dates
  bill_data <- bill_data %>%
    mutate(
      # Extract start date from billing period (assuming format like "Jan 15 - Feb 14")
      bill_month = str_extract(Billing.Period, "^[A-Za-z]+"),
      bill_year = case_when(
        # Handle year transitions in billing periods
        str_detect(Date.Range, "2024") ~ 2024,
        str_detect(Date.Range, "2023") ~ 2023,
        str_detect(Date.Range, "2025") ~ 2025,
        TRUE ~ 2024  # Default assumption
      ),
      
      # Create standardized date (first day of billing month)
      date = as.Date(paste(bill_year, match(bill_month, month.abb), "01", sep = "-")),
      
      # Standardize column names for analysis
      kwh_used = Usage..kWh.,
      current_service = Current.Service....,
      environmental_fee = Environmental.Compliance.Cost....,
      nuclear_cost = Nuclear.Construction.Cost....,
      franchise_fee = Municipal.Franchise.Fee....,
      sales_tax = Sales.Tax....,
      total_bill = Total.Bill....
    ) %>%
    
    # Calculate Georgia Power rate structure components
    mutate(
      # Calculate days in billing period (approximate)
      days_in_period = case_when(
        bill_month %in% c("Feb") ~ 28,
        bill_month %in% c("Apr", "Jun", "Sep", "Nov") ~ 30,
        TRUE ~ 31
      ),
      
      # Basic service charge (fixed daily fee: $0.4603/day)
      basic_service_charge = 0.4603 * days_in_period,
      
      # Separate usage charges from fixed charges in Current Service
      # Current Service = Basic Service + Usage Charges + Fuel Cost Recovery
      estimated_usage_charge = current_service - basic_service_charge,
      
      # Calculate implied $/kWh rate from usage portion only
      implied_rate_per_kwh = if_else(kwh_used > 0, 
                                     estimated_usage_charge / kwh_used, 
                                     NA_real_),
      
      # Total fixed fees that solar CANNOT offset
      total_fixed_fees = basic_service_charge + environmental_fee + 
        nuclear_cost + franchise_fee,
      
      # Variable charges that solar CAN offset (usage portion only)
      solar_offsettable_charges = estimated_usage_charge,
      
      # Percentage of bill that solar can offset
      solar_offset_potential_pct = if_else(total_bill > 0,
                                           solar_offsettable_charges / total_bill * 100,
                                           NA_real_),
      
      # Environmental fee as percentage of current service (should be ~12%)
      environmental_pct = if_else(current_service > 0, 
                                  environmental_fee / current_service * 100, 
                                  NA_real_),
      
      # Season classification
      season = case_when(
        month(date) %in% c(6, 7, 8, 9) ~ "summer",
        month(date) %in% c(12, 1, 2) ~ "winter",
        TRUE ~ "spring_fall"
      ),
      
      # Peak season flag (June-September per GA Power summer rates)
      is_peak_season = month(date) %in% c(6, 7, 8, 9)
    ) %>%
    
    # Sort by date
    arrange(date)
  
  # Data quality checks and summary
  cat("=== GEORGIA POWER MONTHLY BILLS ANALYSIS ===\n")
  cat("Analysis period:", min(bill_data$date), "to", max(bill_data$date), "\n")
  cat("Total bills analyzed:", nrow(bill_data), "\n")
  
  # Annual totals and averages
  annual_summary <- bill_data %>%
    summarise(
      total_kwh = sum(kwh_used, na.rm = TRUE),
      total_bill_amount = sum(total_bill, na.rm = TRUE),
      total_fixed_fees = sum(total_fixed_fees, na.rm = TRUE),
      total_offsettable = sum(solar_offsettable_charges, na.rm = TRUE),
      avg_monthly_kwh = mean(kwh_used, na.rm = TRUE),
      avg_monthly_bill = mean(total_bill, na.rm = TRUE),
      avg_rate = mean(implied_rate_per_kwh, na.rm = TRUE),
      avg_solar_offset_potential = mean(solar_offset_potential_pct, na.rm = TRUE),
      avg_environmental_pct = mean(environmental_pct, na.rm = TRUE)
    )
  
  cat("\nANNUAL SUMMARY:\n")
  cat("Total kWh:", round(annual_summary$total_kwh, 0), "\n")
  cat("Total bill amount: $", round(annual_summary$total_bill_amount, 2), "\n")
  cat("Average monthly kWh:", round(annual_summary$avg_monthly_kwh, 0), "\n")
  cat("Average monthly bill: $", round(annual_summary$avg_monthly_bill, 2), "\n")
  cat("Average effective rate: $", round(annual_summary$avg_rate, 4), "/kWh\n")
  
  cat("\nSOLAR OFFSET ANALYSIS:\n")
  cat("Total fixed fees (solar CANNOT offset): $", round(annual_summary$total_fixed_fees, 2), 
      " (", round(annual_summary$total_fixed_fees/annual_summary$total_bill_amount*100, 1), "% of total bill)\n")
  cat("Variable charges (solar CAN offset): $", round(annual_summary$total_offsettable, 2),
      " (", round(annual_summary$total_offsettable/annual_summary$total_bill_amount*100, 1), "% of total bill)\n")
  cat("Average solar offset potential: ", round(annual_summary$avg_solar_offset_potential, 1), "% per month\n")
  
  return(bill_data)
}

# Load GA Power bills - USER UPDATE PATH
# bill_data <- load_ga_power_bills("ga_power_bills_csv.csv")
```

## 1f. Natural Gas Usage Data (BMG Energy Company)

```{r gas_usage_import}
# Function to load and analyze natural gas usage data
load_gas_usage_data <- function(file_path) {
  
  # Load gas usage data
  gas_data <- read.csv(file_path, stringsAsFactors = FALSE)
  
  # Parse dates and clean data
  gas_data <- gas_data %>%
    mutate(
      # Parse bill dates
      bill_date = as.Date(Bill.Date, format = "%m/%d/%Y"),
      bill_from_date = as.Date(Bill.From.Date, format = "%m/%d/%Y"),
      bill_to_date = as.Date(Bill.To.Date, format = "%m/%d/%Y"),
      
      # Standardize column names
      therms_used = Gas.Used..Therms.,
      heating_degree_days = Heating.Degree.Days,
      avg_temperature = Average.Temperature,
      days_of_service = Days.Of.Service,
      gas_charges = Gas.Charges..Excl..Taxes.,
      other_charges = Other.Charges,
      taxes = Taxes,
      amount_due = Amount.Due,
      
      # Calculate derived metrics
      therms_per_day = therms_used / days_of_service,
      cost_per_therm = if_else(therms_used > 0, gas_charges / therms_used, NA_real_),
      total_cost_per_therm = if_else(therms_used > 0, amount_due / therms_used, NA_real_),
      
      # Season classification
      month = month(bill_date),
      season = case_when(
        month %in% c(12, 1, 2) ~ "winter",
        month %in% c(6, 7, 8) ~ "summer", 
        month %in% c(3, 4, 5) ~ "spring",
        month %in% c(9, 10, 11) ~ "fall",
        TRUE ~ "unknown"
      ),
      
      # Heating season flag (when gas usage is primarily for heating)
      is_heating_season = month %in% c(10, 11, 12, 1, 2, 3),
      
      # Baseline usage estimation (summer months = water heating only)
      is_baseline_month = month %in% c(6, 7, 8, 9),  # Non-heating months
      
      # Calculate degree day efficiency (therms per HDD)
      efficiency_therms_per_hdd = if_else(heating_degree_days > 0, 
                                          therms_used / heating_degree_days, 
                                          NA_real_)
    ) %>%
    arrange(bill_date)
  
  # Calculate usage baselines for emissions analysis
  baseline_usage <- gas_data %>%
    filter(is_baseline_month, therms_used > 0) %>%
    summarise(
      avg_baseline_therms_per_month = mean(therms_used, na.rm = TRUE),
      water_heating_annual_estimate = avg_baseline_therms_per_month * 12
    )
  
  # Heating usage calculation (total - baseline)
  gas_data <- gas_data %>%
    mutate(
      # Estimate water heating vs space heating split
      estimated_water_heating_therms = if_else(
        is_baseline_month, 
        therms_used,  # Summer usage = water heating
        baseline_usage$avg_baseline_therms_per_month  # Winter baseline
      ),
      estimated_space_heating_therms = pmax(0, therms_used - estimated_water_heating_therms)
    )
  
  # Annual summary calculations
  annual_summary <- gas_data %>%
    summarise(
      total_therms = sum(therms_used, na.rm = TRUE),
      total_cost = sum(amount_due, na.rm = TRUE),
      avg_cost_per_therm = mean(total_cost_per_therm, na.rm = TRUE),
      estimated_water_heating_annual = sum(estimated_water_heating_therms, na.rm = TRUE),
      estimated_space_heating_annual = sum(estimated_space_heating_therms, na.rm = TRUE),
      avg_heating_efficiency = mean(efficiency_therms_per_hdd, na.rm = TRUE)
    )
  
  # Data quality and summary output
  cat("=== NATURAL GAS USAGE ANALYSIS ===\n")
  cat("Analysis period:", min(gas_data$bill_date), "to", max(gas_data$bill_date), "\n")
  cat("Total bills analyzed:", nrow(gas_data), "\n")
  cat("Total annual therms:", round(annual_summary$total_therms, 1), "\n")
  cat("Total annual gas cost: $", round(annual_summary$total_cost, 2), "\n")
  cat("Average cost per therm: $", round(annual_summary$avg_cost_per_therm, 3), "\n")
  
  cat("\nUSAGE BREAKDOWN:\n")
  cat("Estimated water heating:", round(annual_summary$estimated_water_heating_annual, 1), "therms/year\n")
  cat("Estimated space heating:", round(annual_summary$estimated_space_heating_annual, 1), "therms/year\n")
  cat("Water heating percentage:", round(annual_summary$estimated_water_heating_annual / annual_summary$total_therms * 100, 1), "%\n")
  
  return(gas_data)
}

# Load gas data - USER UPDATE PATH
# gas_data <- load_gas_usage_data("GAS_bmgenco.csv")
```

## 1g. Data Anomaly Detection and System Events

```{r data_anomaly_detection}
# Function to detect and flag data anomalies for house efficiency calculations
detect_data_anomalies <- function(energy_data, ecobee_data = NULL, manual_events = NULL) {
  
  # Manual event entry system (USER SHOULD UPDATE WITH ACTUAL DATES)
  manual_events_template <- data.frame(
    date = as.Date(c("2024-01-15", "2024-07-20", "2024-09-05")),  # PLACEHOLDER DATES
    event_type = c("equipment_failure", "power_outage", "hvac_repair"),
    description = c("Broken heater", "Power outage during heat storm", "AC service repair - compressor issue"),
    exclude_from_efficiency = c(TRUE, TRUE, TRUE),
    notes = c("Heater malfunction period", "External grid failure", "HVAC component replacement"),
    stringsAsFactors = FALSE
  )
  
  cat("=== DATA ANOMALY DETECTION FRAMEWORK ===\n")
  cat("Manual event tracking template created.\n")
  cat("USER ACTION REQUIRED: Update dates and descriptions for actual events.\n")
  cat("Current placeholder events:\n")
  print(manual_events_template)
  
  cat("\nTO USE: Update manual_events_template with actual dates and descriptions\n")
  cat("Events marked exclude_from_efficiency=TRUE will be filtered from efficiency calculations\n")
  
  return(manual_events_template)
}

# Placeholder function call
# anomaly_events <- detect_data_anomalies(emporia_data, ecobee_data)
```

## 1h. Water Heater Circuit Analysis (Emporia Integration)

```{r water_heater_circuit_analysis}
# Function to analyze water heater usage from dedicated Emporia circuit
analyze_water_heater_circuit <- function(emporia_data, water_heater_circuit_name = "water_heater") {
  
  cat("=== WATER HEATER CIRCUIT ANALYSIS ===\n")
  cat("Analyzing dedicated water heater circuit from Emporia data\n")
  cat("Note: Circuit shared with single exterior power outlet (minimal impact)\n")
  
  # Find water heater circuit in Emporia data
  wh_circuit_names <- grep("water|heater|WH", names(emporia_data), value = TRUE, ignore.case = TRUE)
  
  if(length(wh_circuit_names) > 0) {
    cat("Found potential water heater circuits:\n")
    print(wh_circuit_names)
    cat("USER ACTION: Verify correct circuit name and update function call\n")
  } else {
    cat("No water heater circuit found. Check circuit naming in Emporia data.\n")
    cat("Common names: 'Water_Heater', 'WH', 'Hot_Water', etc.\n")
  }
  
  cat("\nAnalysis will provide:\n")
  cat("- Electrical consumption patterns of gas water heater (pilot, controls, circulation)\n")
  cat("- Validation of gas usage calculations (electrical should be minimal for gas unit)\n")
  cat("- Heat pump water heater conversion baseline\n")
  cat("- Power requirements for heat pump sizing\n")
  
  analysis_framework <- list(
    circuit_identification_needed = TRUE,
    analysis_type = "gas_water_heater_electrical_validation",
    expected_usage = "minimal_electrical_for_gas_unit",
    conversion_baseline = "for_heat_pump_water_heater_sizing"
  )
  
  return(analysis_framework)
}

# USER ACTION: Update circuit name and execute
# wh_analysis <- analyze_water_heater_circuit(emporia_data, "correct_circuit_name")
```

## 1i. Temperature Logger Data (Building Envelope Analysis)

```{r temperature_logger_data}
# Function to load and analyze temperature logger data for building envelope efficiency
load_temperature_logger_data <- function(file_path = NULL) {
  
  cat("=== TEMPERATURE LOGGER DATA FRAMEWORK ===\n")
  cat("Data sources: Crawlspace (post-encapsulation), Attic, Various locations\n")
  cat("Primary use: Building envelope efficiency analysis\n")
  
  # Temperature logger data structure (placeholder)
  logger_locations <- data.frame(
    location = c("crawlspace_encapsulated", "attic", "outdoor", "various_spots"),
    measurement_type = c("post_encapsulation_validation", "attic_efficiency", "reference", "envelope_testing"),
    data_availability = c("longest_dataset", "limited_periods", "weather_correlation", "scattered_readings"),
    primary_use = c("encapsulation_effectiveness", "insulation_analysis", "degree_day_validation", "thermal_bridging"),
    stringsAsFactors = FALSE
  )
  
  cat("Temperature logger framework:\n")
  print(logger_locations)
  
  if(!is.null(file_path)) {
    cat("Loading temperature data from:", file_path, "\n")
    # Actual import logic would go here
  } else {
    cat("No file path provided. Framework ready for data upload.\n")
  }
  
  temp_analysis_framework <- list(
    crawlspace_encapsulation_validation = "effectiveness_of_completed_work",
    attic_efficiency_analysis = "insulation_upgrade_potential", 
    hvac_correlation_with_ecobee = "envelope_impact_on_system_efficiency",
    solar_panel_temperature_modeling = "production_optimization"
  )
  
  return(temp_analysis_framework)
}

# USER ACTION: Provide file path when data available
# temp_logger_analysis <- load_temperature_logger_data()
```

# 2. Solar System Sizing and Configuration

<!--
  SOLAR SYSTEM DECISIONS SUPPORTED BY HOUSE COMPONENT:
  - System size: 3.8kW baseline (10 panels) for 6,540 kWh annual consumption
- Battery storage: Analysis of backup power needs vs cost-benefit
- Sunlight Backup options: Emergency power requirements during outages
- Panel placement: West-facing roof optimization (completed: solar-ready)
- Inverter configuration: String vs power optimizers vs microinverters
- Production estimates: PVWatts integration with local weather patterns
-->
  
  ```{r solar_system_sizing}
# Function to calculate optimal solar system size based on consumption patterns
calculate_solar_system_size <- function(annual_kwh_consumption, 
                                        roof_characteristics = NULL,
                                        offset_percentage = 1.05) {
  
  cat("=== SOLAR SYSTEM SIZING ANALYSIS ===\n")
  cat("Annual consumption baseline:", annual_kwh_consumption, "kWh\n")
  cat("Target offset percentage:", offset_percentage * 100, "%\n")
  
  # Solar production estimates (Georgia, west-facing roof)
  # Based on PVWatts estimates for Decatur, GA
  production_per_kw_west_facing <- 1380  # kWh/kW annually (west orientation factor ~0.85)
  
  # Calculate required system size
  target_annual_production <- annual_kwh_consumption * offset_percentage
  required_system_size_kw <- target_annual_production / production_per_kw_west_facing
  
  # Panel and system specifications
  panel_wattage_options <- c(300, 350, 400, 450)  # Common panel wattages
  
  # Calculate panel counts for different options
  system_options <- data.frame(
    panel_wattage = panel_wattage_options,
    panels_needed = ceiling((required_system_size_kw * 1000) / panel_wattage_options),
    actual_system_size_kw = (ceiling((required_system_size_kw * 1000) / panel_wattage_options) * panel_wattage_options) / 1000,
    estimated_annual_production = ((ceiling((required_system_size_kw * 1000) / panel_wattage_options) * panel_wattage_options) / 1000) * production_per_kw_west_facing,
    offset_percentage = (((ceiling((required_system_size_kw * 1000) / panel_wattage_options) * panel_wattage_options) / 1000) * production_per_kw_west_facing) / annual_kwh_consumption
  )
  
  cat("\nSOLAR SYSTEM OPTIONS:\n")
  print(system_options)
  
  # Recommended system (closest to target without under-sizing)
  recommended_option <- system_options[which.min(abs(system_options$offset_percentage - offset_percentage)), ]
  
  cat("\nRECOMMENDED SYSTEM:\n")
  cat("Panel wattage:", recommended_option$panel_wattage, "W\n")
  cat("Number of panels:", recommended_option$panels_needed, "\n")
  cat("System size:", round(recommended_option$actual_system_size_kw, 2), "kW\n")
  cat("Estimated annual production:", round(recommended_option$estimated_annual_production, 0), "kWh\n")
  cat("Offset percentage:", round(recommended_option$offset_percentage * 100, 1), "%\n")
  
  return(system_options)
}

# Calculate system sizing
# system_options <- calculate_solar_system_size(6540, offset_percentage = 1.05)
```

## 2b. Battery Storage Analysis

```{r battery_storage_analysis}
# Function to analyze battery storage requirements and cost-benefit
analyze_battery_storage <- function(emporia_data = NULL, 
                                    ecobee_data = NULL,
                                    backup_requirements = "essential_loads") {
  
  cat("=== BATTERY STORAGE DECISION ANALYSIS ===\n")
  
  # Define backup scenarios
  backup_scenarios <- data.frame(
    scenario = c("no_battery", "essential_loads", "partial_home", "whole_home"),
    description = c("Grid-tied only", "Refrigerator, lights, outlets", 
                    "Essential + HVAC", "Full home backup"),
    typical_capacity_kwh = c(0, 10, 20, 30),
    estimated_cost = c(0, 12000, 20000, 35000),
    backup_duration_hours = c(0, 24, 12, 8),
    stringsAsFactors = FALSE
  )
  
  cat("Battery storage scenarios:\n")
  print(backup_scenarios)
  
  # Power outage analysis (requires manual event data)
  cat("\nPOWER OUTAGE CONSIDERATIONS:\n")
  cat("- Recent power outages during heat storms (user reported)\n")
  cat("- Georgia Power grid reliability analysis needed\n")
  cat("- Emergency power vs economic arbitrage trade-offs\n")
  
  # Sunlight Backup specific analysis
  cat("\nSUNLIGHT BACKUP OPTIONS:\n")
  cat("- Backup load panel integration\n")
  cat("- Essential circuit prioritization\n")
  cat("- Generator integration capability\n")
  cat("- Time-of-use arbitrage potential\n")
  
  # Economic analysis framework
  cat("\nECONOMIC CONSIDERATIONS:\n")
  cat("- Battery cost: $400-600/kWh installed\n")
  cat("- Federal tax credit applies (30% through 2025)\n")
  cat("- GA Power time-of-use rate optimization\n")
  cat("- Backup power value during outages\n")
  
  # Return analysis framework
  battery_analysis <- list(
    scenarios = backup_scenarios,
    power_outage_frequency = "user_input_required",
    essential_loads_calculation = "from_emporia_circuit_analysis",
    economic_analysis = "integrate_with_financial_component"
  )
  
  return(battery_analysis)
}

# Battery storage analysis
# battery_analysis <- analyze_battery_storage(emporia_data, ecobee_data, "essential_loads")
```

## 2c. Heat Pump Sizing and Configuration

```{r heat_pump_sizing}
# Function to size heat pumps for space and water heating conversion
analyze_heat_pump_conversion <- function(gas_data, ecobee_data = NULL, climate_zone = "3A") {
  
  cat("=== HEAT PUMP CONVERSION ANALYSIS ===\n")
  cat("Climate zone:", climate_zone, "(Georgia - Mixed Humid)\n")
  
  # Extract gas usage breakdown
  if(!is.null(gas_data)) {
    annual_therms <- sum(gas_data$therms_used, na.rm = TRUE)
    water_heating_therms <- sum(gas_data$estimated_water_heating_therms, na.rm = TRUE)
    space_heating_therms <- sum(gas_data$estimated_space_heating_therms, na.rm = TRUE)
    
    cat("Current gas usage:\n")
    cat("- Total annual therms:", round(annual_therms, 1), "\n")
    cat("- Water heating:", round(water_heating_therms, 1), "therms/year\n")
    cat("- Space heating:", round(space_heating_therms, 1), "therms/year\n")
  }
  
  # Heat pump water heater sizing
  cat("\nHEAT PUMP WATER HEATER:\n")
  cat("- Typical efficiency: 3.0-4.0 COP\n")
  cat("- Gas to electric conversion factor: 29.3 kWh/therm equivalent\n")
  if(!is.null(gas_data)) {
    hpwh_annual_kwh <- water_heating_therms * 29.3 / 3.5  # Assume 3.5 COP
    cat("- Estimated annual electricity:", round(hpwh_annual_kwh, 0), "kWh\n")
    cat("- Load increase for solar sizing: +", round(hpwh_annual_kwh, 0), "kWh/year\n")
  }
  
  # Heat pump HVAC sizing
  cat("\nHEAT PUMP HVAC:\n")
  cat("- Requires load calculation for proper sizing\n")
  cat("- Current system age: 2010 AC, 2009 heating (replacement due)\n")
  cat("- Efficiency improvements from envelope work will reduce load\n")
  if(!is.null(gas_data)) {
    hvac_annual_kwh <- space_heating_therms * 29.3 / 2.5  # Assume 2.5 HSPF equivalent COP
    cat("- Estimated heating electricity:", round(hvac_annual_kwh, 0), "kWh/year\n")
    cat("- Combined heating/cooling load for solar sizing\n")
  }
  
  # Integration with existing systems
  cat("\nSYSTEM INTEGRATION:\n")
  cat("- 200A panel upgrade required for heat pump loads\n")
  cat("- Existing ductwork assessment needed\n")
  cat("- Emergency heat backup considerations\n")
  cat("- Refrigerant line modifications\n")
  
  # Return sizing estimates
  heat_pump_analysis <- list(
    water_heater_annual_kwh = if(!is.null(gas_data)) round(water_heating_therms * 29.3 / 3.5, 0) else NA,
    space_heating_annual_kwh = if(!is.null(gas_data)) round(space_heating_therms * 29.3 / 2.5, 0) else NA,
    total_additional_load_kwh = if(!is.null(gas_data)) round((water_heating_therms * 29.3 / 3.5) + (space_heating_therms * 29.3 / 2.5), 0) else NA,
    panel_upgrade_required = TRUE,
    load_calculation_needed = TRUE
  )
  
  return(heat_pump_analysis)
}

# Heat pump conversion analysis
# heat_pump_analysis <- analyze_heat_pump_conversion(gas_data, ecobee_data)
```

# 3. Export Data for Financial and Emissions Components

```{r export_house_profile}
# Function to compile and export house profile data for other components
compile_house_profile <- function(emporia_data = NULL, 
                                  ecobee_data = NULL,
                                  ga_power_data = NULL,
                                  bill_data = NULL,
                                  gas_data = NULL,
                                  system_options = NULL,
                                  battery_analysis = NULL,
                                  heat_pump_analysis = NULL) {
  
  cat("=== COMPILING HOUSE PROFILE FOR EXPORT ===\n")
  
  # Baseline energy consumption
  baseline_consumption <- list(
    annual_kwh_electric = 6540,  # Validated from multiple sources
    annual_therms_gas = if(!is.null(gas_data)) sum(gas_data$therms_used, na.rm = TRUE) else NA,
    daily_avg_kwh = 17.82,
    major_loads = list(
      ac_percent = 29.8,
      heating_percent = 15.0,
      other_percent = 55.2
    )
  )
  
  # Solar system recommendations
  solar_recommendations <- if(!is.null(system_options)) {
    recommended <- system_options[which.min(abs(system_options$offset_percentage - 1.05)), ]
    list(
      recommended_size_kw = recommended$actual_system_size_kw,
      panel_count = recommended$panels_needed,
      panel_wattage = recommended$panel_wattage,
      annual_production_kwh = recommended$estimated_annual_production,
      offset_percentage = recommended$offset_percentage
    )
  } else {
    list(
      recommended_size_kw = 3.8,
      panel_count = 10,
      panel_wattage = 380,
      annual_production_kwh = 6540,
      offset_percentage = 1.0
    )
  }
  
  # Heat pump load additions
  heat_pump_loads <- if(!is.null(heat_pump_analysis)) {
    list(
      water_heater_additional_kwh = heat_pump_analysis$water_heater_annual_kwh,
      space_heating_additional_kwh = heat_pump_analysis$space_heating_annual_kwh,
      total_additional_kwh = heat_pump_analysis$total_additional_load_kwh
    )
  } else {
    list(
      water_heater_additional_kwh = 2400,  # Estimate
      space_heating_additional_kwh = 5000,  # Estimate
      total_additional_kwh = 7400
    )
  }
  
  # Current infrastructure status
  infrastructure_status <- list(
    panel_upgrade_required = TRUE,
    current_panel_amps = 100,
    target_panel_amps = 200,
    roof_solar_ready = TRUE,
    roof_orientation = "west",
    crawlspace_encapsulated = TRUE,
    efficiency_improvements_completed = c("new_roof", "crawlspace_encapsulation", "tree_trimming")
  )
  
  # Rate structure analysis
  rate_analysis <- if(!is.null(bill_data)) {
    annual_summary <- bill_data %>%
      summarise(
        avg_rate = mean(implied_rate_per_kwh, na.rm = TRUE),
        solar_offset_potential_pct = mean(solar_offset_potential_pct, na.rm = TRUE),
        total_fixed_fees_annual = sum(total_fixed_fees, na.rm = TRUE),
        total_bill_annual = sum(total_bill, na.rm = TRUE)
      )
    list(
      avg_electric_rate = annual_summary$avg_rate,
      solar_offset_potential = annual_summary$solar_offset_potential_pct / 100,
      fixed_fees_annual = annual_summary$total_fixed_fees_annual,
      total_electric_bill_annual = annual_summary$total_bill_annual
    )
  } else {
    list(
      avg_electric_rate = 0.12,
      solar_offset_potential = 0.70,
      fixed_fees_annual = 500,
      total_electric_bill_annual = 1200
    )
  }
  
  # Compile complete house profile
  house_profile <- list(
    baseline_consumption = baseline_consumption,
    solar_recommendations = solar_recommendations,
    heat_pump_loads = heat_pump_loads,
    infrastructure_status = infrastructure_status,
    rate_analysis = rate_analysis,
    battery_analysis = battery_analysis,
    data_quality_validated = TRUE,
    analysis_date = Sys.Date()
  )
  
  # Save to RData file for other components
  cat("Saving house profile to house_profile.RData\n")
  save(house_profile, file = "house_profile.RData")
  
  cat("\n=== HOUSE PROFILE SUMMARY ===\n")
  cat("Baseline consumption:", house_profile$baseline_consumption$annual_kwh_electric, "kWh/year\n")
  cat("Recommended solar:", house_profile$solar_recommendations$recommended_size_kw, "kW\n")
  cat("Heat pump additional load:", house_profile$heat_pump_loads$total_additional_kwh, "kWh/year\n")
  cat("Solar offset potential:", round(house_profile$rate_analysis$solar_offset_potential * 100, 1), "% of bill\n")
  
  return(house_profile)
}

# Compile and export house profile
# house_profile <- compile_house_profile(emporia_data, ecobee_data, ga_power_data, 
#                                       bill_data, gas_data, system_options, 
#                                       battery_analysis, heat_pump_analysis)
```

# Usage Instructions

```{r usage_instructions}
cat("=== HOUSE COMPONENT USAGE INSTRUCTIONS ===\n\n")

cat("1. DATA IMPORT:\n")
cat("   - Update file paths in each load function\n")
cat("   - Execute data import functions in order\n")
cat("   - Verify data quality with comparison functions\n\n")

cat("2. MANUAL UPDATES REQUIRED:\n")
cat("   - Update anomaly events with actual dates\n")
cat("   - Identify water heater circuit name in Emporia data\n")
cat("   - Provide temperature logger file path if available\n\n")

cat("3. SYSTEM SIZING:\n")
cat("   - Run solar system sizing with your consumption data\n")
cat("   - Analyze battery storage needs based on backup requirements\n")
cat("   - Calculate heat pump loads for conversion planning\n\n")

cat("4. EXPORT FOR OTHER COMPONENTS:\n")
cat("   - Execute compile_house_profile() to create house_profile.RData\n")
cat("   - This file will be used by financial and emissions components\n\n")

cat("5. KEY DECISIONS SUPPORTED:\n")
cat("   - Solar system size and configuration\n")
cat("   - Battery storage: yes/no and capacity\n")
cat("   - Heat pump sizing for water and space heating\n")
cat("   - 200A panel upgrade requirements and timing\n\n")

cat("OUTPUT: house_profile.RData ready for financial and emissions analysis\n")
```